第一题
```
代码主要结果分析：
修改的函数包括default_init_memmap，default_alloc_pages，default_free_pages。

对于default_init_memmap函数，首先把所有页表建好，同时完成对p\_flag的bit1的设置（调用SetPageProperty函数），使该页为可分配状态，然后再按照注释中的说明设置各项参数，最后将每一页都链接起来加入到free\_list中。最后将base（也就是Head Page）的property参数设为n，表明这一个空闲块含有n个空闲页面。最后将空闲页面总数加n。

对于default_alloc_pages函数，找到第一个大小超过需求量n的空闲块p，然后将p内的所有空闲页面的相关参数修改，并从列表中删除。当处理完所有的页面后，如果发现找到的p的大小超过了n，就将这一块之后的一个页面的property参数设置为p->property-n，这一个页面就成为了新的空闲块的Head Page。最后将总的空闲页面数量减去n，返回p的地址，结束分配。

对于default_free_pages函数，首先找到地址大于base的第一个空闲块的Head Page le，然后在这个页面之前依次插入n个页面，然后将base的相关参数修改使得这个块重新成为空闲块。然后，考察le和base的地址，如果le地址比base大n，则说明两个空闲块是相邻的，通过修改base和le的property参数实现空闲块的合并。接下来，如果在free\_list中base的前趋和base的地址只差1，说明base代表的空闲块之前还有一个相邻的空闲块，通过循环找到这个空闲块的Head Page，然后修改它的property参数以实现空闲块的合并。至此完成了对释放空间的回收。

改进空间：
很多地方参考了答案的算法。
```

第二题
```
代码主要结构分析：参照注释中给出的步骤以及函数设计方式：
(1) 寻找到待循页在数组中序号路口位置
(2) 检查该位置入口是否存在（判断指针是否为空）
(3) 判定create，如果需要create则分配表页位置，如果不直接返回空
(4) 初始化页的引用，初始状态记为引用一次
(5) 通过数组索引得到页的线性头地址
(6) 用memset函数清空该段页空间中原本可能存在的无用内容
(7) 设置页在数组索引中的标志位
(8) 返回以上步骤组织的页入口地址
注意：最后返回的值比较复杂，它是先将后十二位置零，转换成kernel虚址二级页表基址，然后加上偏移，返回找到二级页表项的地址。

思考题：
1、请描述页目录项（Pag Director Entry）和页表（Page Table Entry）中每个组成部分的含义和以及对ucore而言的潜在用处。
答：给一个页表项和一个页目录表项大小为4B即32位。通过观察mmu.h中的定义，我们可以知道：
位的计数是从右向左的：
第一位是存在位，表明该表项对应的页是否存在；
第二位代表页内容是否可写；
第三页代表用户态的软件是否能读取页的内容；
第四位代表是否为写直达；
第五位代表映射的页面有没有被装入缓存，可以帮助实现快表；
第六位代表映射的页面是否在被访问；
第七位代表该页是否被修改过，可以帮助实现虚拟存储中页面在外存和内存中的移动问题；
第八位和第九位必须被置零；
第10、11、12位是留给软件使用的，可以留给软件拓展自己功能的余地。
剩下的20位便是代表被映射的页面的基地址，以配合线性地址中的偏移量实现对应内存的定位。

2、如果ucore执行过程中访问内存，出现了页访问异常，请问硬件要做哪些事情？
答：硬件会把产生异常的线性地址储存在CR2寄存器中，并给出出错码，说明页访问异常的类型，然后保存因为异常被打断的现场，将相关的参数压入栈，  
然后把异常中断号0xe对应的中断服务例程的地址加载到CS和EIP寄存器中，开始由操作系统执行中断服务例程处理异常。操作系统处理完成后，  
恢复之前被打断的程序现场。需要注意的是，在不同的中错码情况下，恢复现场的情况会有不同。有的会在中断位置前，有的会重复执行中断位置代码。
```

第三题
```
代码主要结构分析：参照注释中给出的步骤与设计方法：
(1) 寻找到待循页在数组中序号路口位置
(2) 找到页表相应的基址入口
(3) 页表引用数减，如果到零了要对应释放
(5) 清除释放页在二级目录中的位置
(6) 刷新了原快表

思考题：
1、数据结构Page的全局变量（其实是一个数组）的每一项与页表中的页目录项和页表项有无对应关系？如果有，其对应关系是啥？
答：Page数组中的内容与页目录与页表系项有直接的联系。页目录项的内容是Page的前20位，即页面基地址；页表项中的标志位记录了Page的具体状态。
两者共同组成了Page结构的内容，一个都不能少。

2、如果希望虚拟地址与物理地址相等，则需要如何修改lab2，完成此事？
答：我们现在的段页式的映射机制是：virt addr = linear addr = phy addr + 0xC0000000
   要想让虚拟地址与物理地址相同，则需要重设GDT，建立我们需要的映射。为此我们需要进一步调用gdt_init函数，根据新的gdt全局段描述符表内容（gdt定义位于
pmm.c中），恢复简单的段对等映射关系
```
