```
第一题

代码主要结果分析：
要求给未被映射的地址映射上物理页。调用get_pte函数为访问地址找到相应的物理页表项。如果返回值为空证明失败，此时输出错误信息非正常退出。
如果返回值为0，表示找不到对应的物理地址。则调用pgdir_alloc_page函数针对逻辑地址分配一个物理页。
同样的，如果返回值为空要输出错误信息。

思考题题1：
答：当一个PTE用来描述一般意义上的物理页时，显然它应该维护各种权限和映射关系，以及应该有PTE_P标记；但当它用来描述一个被置换出去的物理页时，
它被用来维护该物理页与 swap 磁盘上扇区的映射关系，并且该 PTE 不应该由MMU 将它解释成物理页映射(即没有 PTE_P 标记)，与此同时对应的权限
则交由 mm_struct 来维护，当对位于该页的内存地址进行访问的时候，必然导致 page fault，然后ucore能够根据 PTE 描述的 swap 项将相应的
物理页重新建立起来，并根据虚存所描述的权限重新设置好 PTE 使得内存访问能够继续正常进行。
思考题2：
答：首先，对于任何一个异常，CPU都要中断，保存当前堆栈信息，处理异常，处理完毕后根据不同异常情况恢复现场（比如有的回到异常位置继续，有的则
回到异常位置上一条执行），这些是对于异常的基本硬件支持。而针对于缺页异样，只有虚拟内存管理情景下可能发生，本质是试图访问在虚拟内存中却不在
实际内存中的地址。所以硬件必须要将不在物理内存中的数据加载进来，如发生页置换，还要考虑是否将被置换的页写入磁盘或其他空间（这也是酌情的，有
些静态场合不需要这一步）。当晚成了异常处理后，CPU需要将现场回复到发生异常处，继续执行。
当异常中再次遇到异常时，系统直接会发生kernel panic

第二题

代码主要结果分析：
在vmm.c中未完成的代码是if循环的else情况。此时get_pte正确返回了需要替换的页。如果替换过程初始化不正常则报错。
正确初始化之后利用(mm->pgdir, page, addr, perm)信息和page_init函数建立物理地址与逻辑地址的关联，并令该替换管理程序得到该页信息。
在swap_fifo.c中完成fifo算法实现：
根据提示在map_swappable中将最近到达的表现加入pra_list_head qeueue的尾部
在swap_out_victim中，将头部，即最先进入队列内容从队列中删去，并且将其放入ptr_page中

思考题：
答：设计方案：可以利用pte观察修改情况，swap_manager框架中原本就保存了调用记录，两者结合可以完成改进clock算法
问答题：
(1)改进clock算法有两种可以选择的替换项，最近未访问未修改项/最近未访问。当然，这里的“最近”特征是相对的，通过多次轮训得到结果。
(2)在ucore中，可以利用pte的write信息来完成      
(3)不断在队列中轮训，寻找最近未访问未修改项/最近未访问的项。如果没有则修改将访问位改为0，知道找到。找到后就可以执行换入换出

```
